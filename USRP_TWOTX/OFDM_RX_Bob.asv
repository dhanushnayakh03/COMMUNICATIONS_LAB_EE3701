
function [M_n, Threshold_graph, H_Tx1, H_Tx2, channel_correlation, ...
          RX_Tx1_Payload_1, RX_Tx1_Payload_2, RX_Tx2_Payload_1, RX_Tx2_Payload_2, ...
          BER_Tx1, BER_Tx2, H_direct] = OFDM_RX_Bob(RX, Parameters_struct)
%% OFDM_RX_Tx1 - Receiver for Alice in Physical Layer Security System
% 
% This function processes the superimposed signals from Tx1 and Tx2,
% separates them using orthogonal pilot patterns, and estimates both channels.
%

%
% INPUTS:
%   RX                - Received signal [1 x N_samples]
%   Parameters_struct - System parameters structure
%
% OUTPUTS:
%   M_n                  - Packet detection metric
%   Threshold_graph      - Detection threshold visualization
%   H_Tx1                - Tx1's channel estimate (time domain, padded to 64)
%   H_Tx2                - Tx2's channel estimate (time domain, padded to 64)
%   channel_correlation  - Correlation coefficient between channels
%   RX_Tx1_Payload_1/2   - Tx1's equalized constellation points (44 each)
%   RX_Tx2_Payload_1/2   - Tx2's equalized constellation points (44 each)
%   BER_Tx1              - Bit Error Rate for Tx1's channel
%   BER_Tx2              - Bit Error Rate for Tx2's channel
%   H_direct             - Direct channel estimate at pilot locations

%% ========== INITIALIZATION ==========
Debug_mode = 'off';
if strcmp(Debug_mode, 'on')
    clearvars -except Debug_mode;
    close all; clc;
    Global_Parameters_PLS;
    load('RX_test_signal.mat'); % Load test RX signal
end

j = 1i;
N_FFT = Parameters_struct.N_FFT;

% Determine payload size from Parameters_struct or default to 44
if isfield(Parameters_struct, 'N_data')
    N_data = Parameters_struct.N_data;
else
    N_data = 44; % Default payload size
end

%% ========== CHANNEL TAP LOGGING SETUP ==========
persistent frame_counter Tx1_tap_log Tx2_tap_log;

% Initialize on first call
if isempty(frame_counter)
    frame_counter = 0 ; 
Tx1_tap_log = struct([]);   % Always reset
Tx2_tap_log = struct([]);

    Tx1_tap_log = struct('frame_num', {}, 'taps', {}, 'BER', {}, 'timestamp', {});
    Tx2_tap_log = struct('frame_num', {}, 'taps', {}, 'BER', {}, 'timestamp', {});
end

% Increment frame counter
frame_counter = frame_counter + 1;

% BER threshold for "close to zero"
BER_THRESHOLD = 1e-4; % Adjust as needed (0.001 = 0.1%)
MAX_FRAMES_TO_LOG = 50;

%% ========== PULSE SHAPING FILTER ==========
% Root Raised Cosine matched filter
rolloff = 0.5;
L_RRC = 6;
OVR = 2;
RRC = rcosdesign(rolloff, L_RRC, OVR, 'sqrt'); % [1x13]
RX_signal = conv(RX, RRC); % Matched filtering [1x3012]

%% ========== PACKET DETECTION (SCHMIDL-COX ALGORITHM) ==========
% Uses repetitive structure of short preamble for synchronization
D = 16; % Delay (half of short preamble slot)
L = 32; % Window length for averaging

C_n = zeros(1,length(RX)-D+1-L);
P_n = zeros(1,length(RX)-D+1-L);
C_k = zeros(1,L);
P_k = zeros(1,L);

for n=1:length(RX)-D+1-L
    for k=1:L
        C_k(k) = RX(n+k-1)*complex(RX(n+k-1+D));
        P_k(k) = abs(RX(n+k-1+D))^2;
    end
    C_n(n) = sum(C_k);
    P_n(n) = sum(P_k);
end
M_n = (abs(C_n).^2)./(P_n.^2);

%% ========== PACKET START DETECTION ==========
Threshold = 0.7;
loc = find(M_n > Threshold);

if isempty(loc)
    warning('No packet detected! Check signal strength or threshold.');
    % Return default values
    M_n = zeros(1, 100);
    Threshold_graph = Threshold * ones(1, 100);
    H_Tx1 = zeros(1, N_FFT);
    H_Tx2 = zeros(1, N_FFT);
    channel_correlation = 0;
    RX_Tx1_Payload_1 = zeros(1, N_data);
    RX_Tx1_Payload_2 = zeros(1, N_data);
    RX_Tx2_Payload_1 = zeros(1, N_data);
    RX_Tx2_Payload_2 = zeros(1, N_data);
    BER_Tx1 = 0.5;
    BER_Tx2 = 0.5;
    H_direct = zeros(N_FFT,1);
    return;
end

% Find packet front (large gap in detection metric)
temp_1 = [loc, 0];
temp_2 = [0, loc];
temp_3 = temp_1 - temp_2;
Packet_Front = find(temp_3 > 300);

if isempty(Packet_Front)
    Packet_Front_idx = loc(1);
else
    Packet_Front_idx = loc(Packet_Front);
end

% Verify packet is sustained above threshold
Length_over_Threshold = 230;
idx = Packet_Front_idx(1) + L_RRC + 1; % Default

for x = 1:length(Packet_Front_idx)
    if Packet_Front_idx(x) + Length_over_Threshold <= length(M_n)
        if M_n(Packet_Front_idx(x) + Length_over_Threshold) > Threshold
            idx = Packet_Front_idx(x) + L_RRC + 1;
            break;
        end
    end
end

% Visualization marker
Threshold_graph = Threshold * ones(1, length(M_n));
if idx - L_RRC - 1 <= length(Threshold_graph)
    Threshold_graph(idx - L_RRC - 1) = 1.15;
end

%% ========== FRAME EXTRACTION AND DOWNSAMPLING ==========
% Frame structure: Short(160) + Long(160) + Payload1(80) + Payload2(80) = 480 samples
Frame_length = 480;

% Extract frame and downsample by OVR
if idx + OVR*Frame_length - 1 > length(RX_signal)
    warning('Packet position exceeds signal length. Adjusting...');
    idx = max(1, length(RX_signal) - OVR*Frame_length);
end

Frame_DWN_sampling = RX_signal(idx:OVR:min(idx + OVR*Frame_length - 1, length(RX_signal)));

% Ensure frame length is correct
if length(Frame_DWN_sampling) < Frame_length
    warning('Frame too short after downsampling. Padding with zeros.');
    Frame_DWN_sampling = [Frame_DWN_sampling, zeros(1, Frame_length - length(Frame_DWN_sampling))];
end
Frame_DWN_sampling = Frame_DWN_sampling(1:Frame_length); % Trim to exact length

%% ========== COARSE CFO ESTIMATION ==========
% Uses correlation between repeated short preamble slots
Short_preamble_slot_length = 16;

slot5 = Frame_DWN_sampling(Short_preamble_slot_length*5 + 1 : Short_preamble_slot_length*6);
slot6 = Frame_DWN_sampling(Short_preamble_slot_length*6 + 1 : Short_preamble_slot_length*7);
z_coarse = slot5 * slot6';

f_Coarse_est = (-1/(2*pi*Short_preamble_slot_length*Parameters_struct.Ts)) * angle(z_coarse);
Frame_After_Coarse = Frame_DWN_sampling .* exp(-j*2*pi*f_Coarse_est*Parameters_struct.Ts*(0:Frame_length-1));

%% ========== FINE CFO ESTIMATION ==========
% Uses correlation between two long preamble symbols
long_preamble_1 = Frame_After_Coarse(Short_preamble_slot_length*12 + 1 : Short_preamble_slot_length*16);
long_preamble_2 = Frame_After_Coarse(Short_preamble_slot_length*16 + 1 : Short_preamble_slot_length*20);
z_fine = long_preamble_1 * long_preamble_2';

f_Fine_est = (-1/(2*pi*64*Parameters_struct.Ts)) * angle(z_fine);
Frame_After_Fine = Frame_After_Coarse .* exp(-j*2*pi*f_Fine_est*Parameters_struct.Ts*(0:Frame_length-1));

%% ========== INITIAL CHANNEL ESTIMATION (PREAMBLE-BASED) ==========
% This provides a coarse estimate; refined estimates come from pilots
Long_preamble_1_FFT = fftshift(fft(long_preamble_1));
Long_preamble_2_FFT = fftshift(fft(long_preamble_2));
H_est_preamble = 0.5 * (Long_preamble_1_FFT + Long_preamble_2_FFT) .* ...
                 conj(Parameters_struct.Long_preamble_slot_Frequency);

%% ========================================================================
%% ========== PAYLOAD 1 PROCESSING ==========
%% ========================================================================
RX_Payload_1_time = Frame_After_Fine(321:400);      % Extract payload 1 [1x80]
RX_Payload_1_no_CP = RX_Payload_1_time(17:80);     % Remove cyclic prefix [1x64]
RX_Payload_1_Frequency = fftshift(fft(RX_Payload_1_no_CP)); % FFTshifted [1xN_FFT]

%% --- Setup & Tx1 pilots (common across payloads) ---
Tx1_pilot_idx     = Parameters_struct.Tx1_pilot_idx(:).';       % ensure row vector
Tx1_pilot_symbols = Parameters_struct.Tx1_pilot_symbols(:).';   % row vector
Lch_Tx1 = Parameters_struct.Lch_Tx1;
Np_Tx1 = length(Tx1_pilot_idx);

% Sanity checks
assert(numel(Tx1_pilot_idx) == numel(Tx1_pilot_symbols), 'Tx1 pilot idx and symbols length mismatch');
assert(all(Tx1_pilot_idx >= 1 & Tx1_pilot_idx <= N_FFT), 'Tx1_pilot_idx out of range');

% Extract pilot observations (column vectors)
Yp_Tx1_1 = RX_Payload_1_Frequency(Tx1_pilot_idx).';  % [Np x 1]
Xp_Tx1   = Tx1_pilot_symbols.';                     % [Np x 1]

% Convert pilot indices to centered frequency bins (for fftshifted representation)
% MATLAB indexing p=1..N corresponds to k_centered = (p-1) - N/2  (for Tx2n N)
k_centered_Tx1 = (Tx1_pilot_idx - 1).' - (N_FFT/2);  % [Np x 1] column

% Build Vandermonde matrix (vectorized)
F_Tx1 = exp(-1j * 2*pi * (k_centered_Tx1) * (0:(Lch_Tx1-1)) / N_FFT);  % [Np x Lch_Tx1]

% LS estimate (time-domain taps)
h_Tx1_1 = F_Tx1 \ (Yp_Tx1_1 ./ Xp_Tx1);  % [Lch_Tx1 x 1]

% Reconstruct full frequency response with zero-padding and fftshift to match RX ordering
h_padded = [h_Tx1_1; zeros(N_FFT - Lch_Tx1, 1)];     % [N_FFT x 1]
H_Tx1_recon_1 = fftshift(fft(h_padded)).';           % [1 x N_FFT]

%% --- Tx2 (Payload 1) ---
Tx2_pilot_idx     = Parameters_struct.Tx2_pilot_idx(:).';
Tx2_pilot_symbols = Parameters_struct.Tx2_pilot_symbols(:).';
Lch_Tx2 = Parameters_struct.Lch_Tx2;
Np_Tx2 = length(Tx2_pilot_idx);

assert(numel(Tx2_pilot_idx) == numel(Tx2_pilot_symbols), 'Tx2 pilot idx and symbols length mismatch');
assert(all(Tx2_pilot_idx >= 1 & Tx2_pilot_idx <= N_FFT), 'Tx2_pilot_idx out of range');

Yp_Tx2_1 = RX_Payload_1_Frequency(Tx2_pilot_idx).';  % [Np x 1]
Xp_Tx2   = Tx2_pilot_symbols.';                     % [Np x 1]

k_centered_Tx2 = (Tx2_pilot_idx - 1).' - (N_FFT/2);
F_Tx2 = exp(-1j * 2*pi * (k_centered_Tx2) * (0:(Lch_Tx2-1)) / N_FFT);

h_Tx2_1 = F_Tx2 \ (Yp_Tx2_1 ./ Xp_Tx2);   % [Lch_Tx2 x 1]

h_padded_e = [h_Tx2_1; zeros(N_FFT - Lch_Tx2, 1)];
H_Tx2_recon_1 = fftshift(fft(h_padded_e)).';        % [1 x N_FFT]

%% --- Zero-Forcing Equalization for Payload 1 ---
Tx_total_pilots = union(Tx1_pilot_symbols,Tx2_pilot_symbols);
Yp_payload1 = RX_Payload_1_Frequency(Tx_total_pilots);
Xp_payload1 = Tx_total_pilots ; 

k_centered_payload1 = (Tx_total_pilots - 1).' - (N_FFT/2);
F_Tx_total = exp(-1j * 2*pi * (k_centered_payload1) * (0:(Lch_Tx1 + Lch_Tx2-1)) / N_FFT);

h_Tx_total = F_Tx_total \ (Yp_payload1./ Xp_payload1);   % [Lch_Tx2 x 1]

h_padded_e = [h_Tx_total; zeros(N_FFT - L_ch_Tx1+Lch_Tx2, 1)];
H_Tx_total = fftshift(fft(h_padded_e)).'; 

H_Tx_total(abs(H_Tx_total) < 1e-12) = 1e-12;


RX_Tx_Payload_1_Frequency_Eq = RX_Payload_1_Frequency ./ H_Tx_total; % [1xN_FFT]


%% ========================================================================
%% ========== PAYLOAD 2 PROCESSING ==========
%% ========================================================================
RX_Payload_2_time = Frame_After_Fine(401:480);      % Extract payload 2 [1x80]
RX_Payload_2_no_CP = RX_Payload_2_time(17:80);     % Remove cyclic prefix [1x64]
RX_Payload_2_Frequency = fftshift(fft(RX_Payload_2_no_CP)); % FFTshifted [1xN_FFT]

%% --- Tx1 (Payload 2) ---
Yp_Tx1_2 = RX_Payload_2_Frequency(Tx1_pilot_idx).';  % [Np x 1]
h_Tx1_2  = F_Tx1 \ (Yp_Tx1_2 ./ Xp_Tx1);             % [Lch_Tx1 x 1]

h_padded = [h_Tx1_2; zeros(N_FFT - Lch_Tx1, 1)];
H_Tx1_recon_2 = fftshift(fft(h_padded)).';          % [1 x N_FFT]

%% --- Tx2 (Payload 2) ---
Yp_Tx2_2 = RX_Payload_2_Frequency(Tx2_pilot_idx).';  % [Np x 1]
h_Tx2_2  = F_Tx2 \ (Yp_Tx2_2 ./ Xp_Tx2);             % [Lch_Tx2 x 1]

h_padded_e = [h_Tx2_2; zeros(N_FFT - Lch_Tx2, 1)];
H_Tx2_recon_2 = fftshift(fft(h_padded_e)).';        % [1 x N_FFT]

%% --- Zero-Forcing Equalization for Payload 1 ---
Tx_total_pilots = union(Tx1_pilot_symbols,Tx2_pilot_symbols);
Yp_payload2 = RX_Payload_2_Frequency(Tx_total_pilots);
Xp_payload2 = Tx_total_pilots ; 

k_centered_payload2 = (Tx_total_pilots - 1).' - (N_FFT/2);
F_Tx_total = exp(-1j * 2*pi * (k_centered_payload2) * (0:(Lch_Tx1 + Lch_Tx2-1)) / N_FFT);

h_Tx_total = F_Tx_total \ (Yp_payload2./ Xp_payload2);   % [Lch_Tx2 x 1]

h_padded_e = [h_Tx_total; zeros(N_FFT - L_ch_Tx1+Lch_Tx2, 1)];
H_Tx_total = fftshift(fft(h_padded_e)).'; 

H_Tx_total(abs(H_Tx_total) < 1e-12) = 1e-12;


RX_Tx_Payload_2_Frequency_Eq = RX_Payload_2_Frequency ./ H_Tx_total; % [1xN_FFT]


%% ========== DIRECT CHANNEL ESTIMATE ==========
H_direct = zeros(N_FFT,1); 
H_direct(Tx1_pilot_idx) = Yp_Tx1_1 ./ Xp_Tx1;

%% ========================================================================
%% ========== CHANNEL ANALYSIS AND CORRELATION ==========
%% ========================================================================

% Average channel estimates across both payload symbols
h_Tx1_avg = 0.5 * (h_Tx1_1 + h_Tx1_2); % [Lch_Tx1 x 1]
h_Tx2_avg = 0.5 * (h_Tx2_1 + h_Tx2_2); % [Lch_Tx2 x 1]

% Store padded versions for output
H_Tx1 = [h_Tx1_avg.', zeros(1, N_FFT - Lch_Tx1)]; % [1x64]
H_Tx2 = [h_Tx2_avg.', zeros(1, N_FFT - Lch_Tx2)]; % [1x64]

% Calculate normalized correlation coefficient
correlation_numerator = abs(h_Tx1_avg' * h_Tx2_avg);
correlation_denominator = norm(h_Tx1_avg) * norm(h_Tx2_avg);

if correlation_denominator < eps
    channel_correlation = 0;
else
    channel_correlation = correlation_numerator / correlation_denominator;
end

%% ========================================================================
%% ========== DATA DEMODULATION AND SYMBOL MAPPING ==========
%% ========================================================================

% Get data subcarrier indices (excluding pilots, DC, and virtual carriers)
if isfield(Parameters_struct, 'data_idx')
    data_idx = Parameters_struct.data_idx; % Use predefined indices
else
    % Auto-generate data indices if not provided (44 data subcarriers)
    % Exclude: DC(33), Virtual(1-6, 60-64), Tx1 pilots, Tx2 pilots
    all_idx = 1:64;
    exclude_idx = [1:6, 33, 60:64, Tx1_pilot_idx, Tx2_pilot_idx];
    data_idx = setdiff(all_idx, exclude_idx);
    data_idx = data_idx(1:min(N_data, length(data_idx))); % Limit to N_data
end

%% --- Tx Data Demodulation ---
% Payload 1
RX_Tx1_data_1_eq = RX_Tx_Payload_1_Frequency_Eq(data_idx); % [1 x N_data]
RX_Tx1_data_1_demod = pskdemod(RX_Tx1_data_1_eq, 4, pi/4); % QPSK demodulation

% Payload 2
RX_Tx1_data_2_eq = RX_Tx_Payload_2_Frequency_Eq(data_idx); % [1 x N_data]
RX_Tx1_data_2_demod = pskdemod(RX_Tx1_data_2_eq, 4, pi/4);

% %% --- Tx2's Data Demodulation ---
% % Payload 1
% RX_Tx2_data_1_eq = RX_Tx2_Payload_1_Frequency_Eq(data_idx); % [1 x N_data]
% RX_Tx2_data_1_demod = pskdemod(RX_Tx2_data_1_eq, 4, pi/4);
% 
% % Payload 2
% RX_Tx2_data_2_eq = RX_Tx2_Payload_2_Frequency_Eq(data_idx); % [1 x N_data]
% RX_Tx2_data_2_demod = pskdemod(RX_Tx2_data_2_eq, 4, pi/4);

%% Store equalized constellation points for visualization
RX_Tx_Payload_1 = RX_Tx1_data_1_eq;
RX_Tx_Payload_2 = RX_Tx1_data_2_eq;
% RX_Tx2_Payload_1 = RX_Tx2_data_1_eq;
% RX_Tx2_Payload_2 = RX_Tx2_data_2_eq;

%% ========================================================================
%% ========== BIT ERROR RATE CALCULATION ==========
%% ========================================================================

% Tx BER
if isfield(Parameters_struct, 'data_Payload_Tx1_1') && isfield(Parameters_struct, 'data_Payload_Tx1_2')
    % Check if data is in a nested structure
    if isstruct(Parameters_struct.data_Payload_Tx1_1)
        data_Tx1_1_ref = Parameters_struct.data_Payload_Tx1_1.data_Payload_1;
        data_Tx1_2_ref = Parameters_struct.data_Payload_Tx1_2.data_Payload_2;
    else
        data_Tx1_1_ref = Parameters_struct.data_Payload_Tx1_1;
        data_Tx1_2_ref = Parameters_struct.data_Payload_Tx1_2;
    end

    % Trim to match received data length
    len_match = min([length(data_Tx1_1_ref), length(RX_Tx1_data_1_demod)]);
    errors_Tx1_1 = abs(sign(data_Tx1_1_ref(1:len_match) - RX_Tx1_data_1_demod(1:len_match)));

    len_match = min([length(data_Tx1_2_ref), length(RX_Tx1_data_2_demod)]);
    errors_Tx1_2 = abs(sign(data_Tx1_2_ref(1:len_match) - RX_Tx1_data_2_demod(1:len_match)));

    Error_bits_Tx1 = sum(errors_Tx1_1) + sum(errors_Tx1_2);
    Total_bits_Tx1 = length(errors_Tx1_1) + length(errors_Tx1_2);
    BER_Tx1 = Error_bits_Tx1 / Total_bits_Tx1;
else
    BER_Tx1 = NaN; % No reference data available
end

% % Tx2's BER
% if isfield(Parameters_struct, 'data_Payload_Tx2_1') && isfield(Parameters_struct, 'data_Payload_Tx2_2')
%     % Check if data is in a nested structure
%     if isstruct(Parameters_struct.data_Payload_Tx2_1)
%         data_Tx2_1_ref = Parameters_struct.data_Payload_Tx2_1.data_Payload_1;
%         data_Tx2_2_ref = Parameters_struct.data_Payload_Tx2_2.data_Payload_2;
%     else
%         data_Tx2_1_ref = Parameters_struct.data_Payload_Tx2_1;
%         data_Tx2_2_ref = Parameters_struct.data_Payload_Tx2_2;
%     end
% 
%     % Trim to match received data length
%     len_match = min([length(data_Tx2_1_ref), length(RX_Tx2_data_1_demod)]);
%     errors_Tx2_1 = abs(sign(data_Tx2_1_ref(1:len_match) - RX_Tx2_data_1_demod(1:len_match)));
% 
%     len_match = min([length(data_Tx2_2_ref), length(RX_Tx2_data_2_demod)]);
%     errors_Tx2_2 = abs(sign(data_Tx2_2_ref(1:len_match) - RX_Tx2_data_2_demod(1:len_match)));
% 
%     Error_bits_Tx2 = sum(errors_Tx2_1) + sum(errors_Tx2_2);
%     Total_bits_Tx2 = length(errors_Tx2_1) + length(errors_Tx2_2);
%     BER_Tx2 = Error_bits_Tx2 / Total_bits_Tx2;
% else
%     BER_Tx2 = NaN;
% end

%% ========================================================================
%% ========== CHANNEL TAP LOGGING (FOR FIRST 250 FRAMES WITH LOW BER) ==========
%% ========================================================================


MAX_Tx1_LOGS = 50;
MAX_Tx2_LOGS = 50;
if length(Tx1_tap_log) <= MAX_Tx1_LOGS || length(Tx2_tap_log) <= MAX_Tx2_LOGS
%% ---- Tx1 logging (independent) ----
if length(Tx1_tap_log) < MAX_Tx1_LOGS && ~isnan(BER_Tx1) && BER_Tx1 <= BER_THRESHOLD
    log_entry_Tx1.frame_num = frame_counter;
    log_entry_Tx1.taps = h_Tx1_avg(:).';
    log_entry_Tx1.BER = BER_Tx1;
    log_entry_Tx1.timestamp = datestr(now, 'yyyy-mm-dd HH:MM:SS.FFF');

    Tx1_tap_log(end+1) = log_entry_Tx1;
    fprintf('[Frame %d] Tx1: BER = %.6f  --> Logged (%d/%d)\n', ...
             frame_counter, BER_Tx1, length(Tx1_tap_log), MAX_Tx1_LOGS);
end

%% ---- Tx2 logging (independent) ----
if length(Tx2_tap_log) < MAX_Tx2_LOGS && ~isnan(BER_Tx2) && BER_Tx2 <= BER_THRESHOLD
    log_entry_Tx2.frame_num = frame_counter;
    log_entry_Tx2.taps = h_Tx2_avg(:).';
    log_entry_Tx2.BER = BER_Tx2;
    log_entry_Tx2.timestamp = datestr(now, 'yyyy-mm-dd HH:MM:SS.FFF');

    Tx2_tap_log(end+1) = log_entry_Tx2;
    fprintf('[Frame %d] Tx2: BER = %.6f  --> Logged (%d/%d)\n', ...
             frame_counter, BER_Tx2, length(Tx2_tap_log), MAX_Tx2_LOGS);
end

%% ---- Periodic & Safe Auto-Save ----
if mod(frame_counter,50)==0 || length(Tx1_tap_log)==MAX_Tx1_LOGS || length(Tx2_tap_log)==MAX_Tx2_LOGS
    if ~isempty(Tx1_tap_log), save('Tx1_channel_taps_log.mat', 'Tx1_tap_log'); end
    if ~isempty(Tx2_tap_log), save('Tx2_channel_taps_log.mat', 'Tx2_tap_log'); end
end
end


% %% ---- Final Exit (only when both FULL) ----
% if length(Tx1_tap_log) >= MAX_Tx1_LOGS && length(Tx2_tap_log) >= MAX_Tx2_LOGS
%     fprintf('\n=== DONE: Tx1 & Tx2 logs FULLY FILLED. Stopping simulation. ===\n');
%     save('Tx1_channel_taps_log.mat', 'Tx1_tap_log');
%     save('Tx2_channel_taps_log.mat', 'Tx2_tap_log');
% 
% end


%% ========================================================================
%% ========== DEBUG VISUALIZATION ==========
%% ========================================================================

if strcmp(Debug_mode, 'on')
    figure('Name', 'Alice RX - Detailed Analysis', 'Position', [50 50 1600 900]);

    % ===== Row 1: Raw Signal =====
    subplot(3, 5, 1);
    plot(RX, '.', 'MarkerSize', 4);
    title('RX Raw Constellation');
    xlabel('Real'); ylabel('Imaginary');
    axis([-1.5 1.5 -1.5 1.5]); axis square; grid on;

    subplot(3, 5, 2);
    plot(real(RX), 'b', 'LineWidth', 0.5);
    title('I Component'); xlabel('Sample'); ylabel('Amplitude');
    axis([1 length(RX) -1.5 1.5]); grid on;

    subplot(3, 5, 3);
    plot(imag(RX), 'r', 'LineWidth', 0.5);
    title('Q Component'); xlabel('Sample'); ylabel('Amplitude');
    axis([1 length(RX) -1.5 1.5]); grid on;

    subplot(3, 5, 4);
    [Spectrum_waveform, Welch_Spectrum_frequency] = pwelch(RX, [], [], [], ...
        1/Parameters_struct.Ts, 'centered', 'power');
    plot(Welch_Spectrum_frequency/1e6, pow2db(Spectrum_waveform), 'LineWidth', 1.5);
    title('Power Spectral Density');
    xlabel('Frequency (MHz)'); ylabel('Power (dB)');
    grid on;

    subplot(3, 5, 5);
    text(0.1, 0.8, 'System Info', 'FontSize', 12, 'FontWeight', 'bold');
    text(0.1, 0.6, sprintf('FFT Size: %d', N_FFT), 'FontSize', 9);
    text(0.1, 0.5, sprintf('Data SC: %d', N_data), 'FontSize', 9);
    text(0.1, 0.4, sprintf('f_{coarse}: %.2f Hz', f_Coarse_est), 'FontSize', 9);
    text(0.1, 0.3, sprintf('f_{fine}: %.2f Hz', f_Fine_est), 'FontSize', 9);
    text(0.1, 0.2, sprintf('Packet idx: %d', idx), 'FontSize', 9);
    axis off;

    % ===== Row 2: Detection & Channels =====
    subplot(3, 5, 6);
    plot(1:length(M_n), M_n, 'b', 'LineWidth', 1.5);
    hold on;
    plot(1:length(M_n), Threshold_graph, 'r--', 'LineWidth', 2);
    title('Packet Detection Metric');
    xlabel('Sample'); ylabel('M_n');
    legend('M_n', 'Threshold', 'Location', 'best');
    axis([1 length(M_n) 0 1.2]); grid on;

    subplot(3, 5, 7);
    stem(0:Lch_Tx1-1, abs(h_Tx1_avg), 'b', 'LineWidth', 2, 'MarkerSize', 8);
    title('Tx1 Channel Taps |h_{Tx1}|');
    xlabel('Tap Index'); ylabel('Magnitude');
    grid on;

    subplot(3, 5, 8);
    stem(0:Lch_Tx2-1, abs(h_Tx2_avg), 'm', 'LineWidth', 2, 'MarkerSize', 8);
    title('Tx2 Channel Taps |h_{Tx2}|');
    xlabel('Tap Index'); ylabel('Magnitude');
    grid on;

    subplot(3, 5, 9);
    bar([norm(h_Tx1_avg), norm(h_Tx2_avg)]);
    set(gca, 'XTickLabel', {'Tx1', 'Tx2'});
    title('Channel Norms');
    ylabel('||h||'); grid on;

    subplot(3, 5, 10);
    text(0.1, 0.8, 'Channel Statistics', 'FontSize', 12, 'FontWeight', 'bold');
    text(0.1, 0.6, sprintf('Correlation: %.4f', channel_correlation), 'FontSize', 10);
    text(0.1, 0.5, sprintf('||h_{Tx1}||: %.4f', norm(h_Tx1_avg)), 'FontSize', 10);
    text(0.1, 0.4, sprintf('||h_{Tx2}||: %.4f', norm(h_Tx2_avg)), 'FontSize', 10);
    if channel_correlation < 0.3
        text(0.1, 0.2, 'Security: HIGH', 'FontSize', 10, 'Color', 'g', 'FontWeight', 'bold');
    elseif channel_correlation < 0.6
        text(0.1, 0.2, 'Security: MEDIUM', 'FontSize', 10, 'Color', [1 0.5 0], 'FontWeight', 'bold');
    else
        text(0.1, 0.2, 'Security: LOW', 'FontSize', 10, 'Color', 'r', 'FontWeight', 'bold');
    end
    axis off;

    % ===== Row 3: Equalization Results =====
    subplot(3, 5, 11);
    plot([RX_Tx1_Payload_1, RX_Tx1_Payload_2], '*b', 'MarkerSize', 8);
    title(sprintf('Tx1 Equalized (%d symbols)\nBER = %.4f', length([RX_Tx1_Payload_1, RX_Tx1_Payload_2]), BER_Tx1));
    xlabel('Real'); ylabel('Imaginary');
    axis([-1.5 1.5 -1.5 1.5]); axis square; grid on;

    subplot(3, 5, 12);
    plot([RX_Tx2_Payload_1, RX_Tx2_Payload_2], '*m', 'MarkerSize', 8);
    title(sprintf('Tx2 Equalized (%d symbols)\nBER = %.4f', length([RX_Tx2_Payload_1, RX_Tx2_Payload_2]), BER_Tx2));
    xlabel('Real'); ylabel('Imaginary');
    axis([-1.5 1.5 -1.5 1.5]); axis square; grid on;

    subplot(3, 5, 13);
    H_Tx1_freq = fft([h_Tx1_avg; zeros(N_FFT - Lch_Tx1, 1)]);
    plot(1:N_FFT, abs(H_Tx1_freq), 'b', 'LineWidth', 1.5);
    hold on;
    stem(Tx1_pilot_idx, abs(H_Tx1_freq(Tx1_pilot_idx)), 'r', 'LineWidth', 2);
    title('Tx1 |H(f)|');
    xlabel('Subcarrier'); ylabel('Magnitude');
    legend('Estimated', 'Pilots', 'Location', 'best');
    grid on;

    subplot(3, 5, 14);
    H_Tx2_freq = fft([h_Tx2_avg; zeros(N_FFT - Lch_Tx2, 1)]);
    plot(1:N_FFT, abs(H_Tx2_freq), 'm', 'LineWidth', 1.5);
    hold on;
    stem(Tx2_pilot_idx, abs(H_Tx2_freq(Tx2_pilot_idx)), 'r', 'LineWidth', 2);
    title('Tx2 |H(f)|');
    xlabel('Subcarrier'); ylabel('Magnitude');
    legend('Estimated', 'Pilots', 'Location', 'best');
    grid on;

    subplot(3, 5, 15);
    % Phase comparison
    phase_Tx1 = angle(H_Tx1_freq);
    phase_Tx2 = angle(H_Tx2_freq);
    plot(1:N_FFT, phase_Tx1, 'b', 'LineWidth', 1.5);
    hold on;
    plot(1:N_FFT, phase_Tx2, 'm', 'LineWidth', 1.5);
    title('Channel Phase Response');
    xlabel('Subcarrier'); ylabel('Phase (rad)');
    legend('Tx1', 'Tx2', 'Location', 'best');
    grid on;

    set(gcf, 'Units', 'centimeters', 'position', [1 2 55 28]);
end

%% ========== FUNCTION END ==========
end